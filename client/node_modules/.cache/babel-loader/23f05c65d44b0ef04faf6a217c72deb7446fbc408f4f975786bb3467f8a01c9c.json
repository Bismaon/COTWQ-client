{"ast":null,"code":"// ThreeScene.ts\n\nimport * as THREE from \"three\";\nimport { Countries } from \"../models/Countries\";\nimport { UserSession } from \"../services/UserSession\";\nimport { createTable, getIndexFromLocation } from \"../typescripts/countriesTable\";\nimport { Timer } from \"../utils/Timer\";\nimport { loadModel } from \"../utils/loader\";\nimport { setupScene, animate, moveModelTo, getIsPlaying, getIsRotating, toggleIsRotating, setCameraPosition, getIntersect, toggleIsPlaying } from \"../utils/scene\";\n\n// Create variables\nexport let timer;\nlet allCountriesCaps;\nlet allCountries;\nlet modelParent;\nlet globe;\nlet currUser;\nlet isFollowing = false;\nconst colorsArray = [];\nconst colorDict = {\n  unknown: 0,\n  found: 1,\n  unavailable: 2,\n  error: 3,\n  selected: 4\n};\nconst countries = new Countries();\nconst users = new UserSession();\nlet renderer;\nlet scene;\n//!!!!!! CREATE A SETUP FUNCTION FOR EVERYTHING IN THIS FILE, SO CAN CALL FROM MODEL.TSX\n//!? Dunno if necessary anymore\nexport function setupModel() {\n  [renderer, scene] = setupScene(); // Destructure the result of setupScene()\n\n  // Load and initialize the model\n  loadAndInitializeModel().then(result => {\n    console.log(\"Loaded model successfully\");\n    // Additional actions to execute after successful resolution\n  }).catch(error => {\n    console.error(\"An error occurred:\", error); // This will execute if the Promise is rejected\n    return;\n  });\n  createTable(countries.getCountriesArray()); // Create table with countries\n  timer = new Timer();\n}\n\n/**\r\n * Asynchronously loads and initializes the 3D model.\r\n */\nasync function loadAndInitializeModel() {\n  try {\n    modelParent = await loadModel(scene, colorsArray);\n    if (!modelParent) {\n      console.error(\"MODEL ERROR: Model is null or undefined.\");\n      return;\n    }\n    animate(renderer, modelParent); // Start animation\n    moveModelTo(modelParent, 90, null, null); // Move model to the right side of the screen\n    globe = modelParent.children[0];\n    allCountriesCaps = globe.children[1];\n    allCountries = globe.children[0];\n\n    // Set countries to base color\n    for (let i = 0; i < countries.getSize(); i++) {\n      changeColorTo(countries.getCountriesArray()[i].getCountryLocation()[0], countries.getCountriesArray()[i].getCountryLocation()[1], \"unknown\");\n    }\n  } catch (error) {\n    console.error(\"An error occurred while loading the model:\", error);\n  }\n}\n\n/**\r\n * Handles the mouse up event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\nexport function handleMouseUp(event) {\n  if (event.button === 0 && !getIsPlaying() && !getIsRotating()) {\n    toggleIsRotating(); // Toggle rotation if not playing and not rotating\n  }\n}\n\n/**\r\n * Handles the mouse down event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\nexport function handleMouseDown(event) {\n  if (event.button === 0 && getIsPlaying() && getIsRotating()) {\n    toggleIsRotating(); // Toggle rotation if playing and rotating\n  }\n}\n\n/**\r\n * Handles changes in the textbox input.\r\n */\nexport function handleTextboxChange() {\n  const textBox = document.getElementById(\"textbox\");\n  if (!getIsPlaying()) {\n    toggleIsPlaying();\n    timer.reset();\n    timer.start();\n  }\n  if (textBox) {\n    const countryName = processText(textBox.value);\n    const indexCountry = countries.exists(countryName);\n    if (indexCountry !== -1) {\n      const wantedCountry = countries.getCountriesArray()[indexCountry];\n      foundSearch(wantedCountry, textBox);\n      console.log(countries.getFound());\n      console.log(\"Missing: \" + (countries.getSize() - countries.getFound()));\n    }\n  }\n}\n\n/**\r\n * Checks if the wanted country is found, changes its status if not found,\r\n * updates its color on the globe, and handles related actions like clearing\r\n * the textbox and setting the camera position.\r\n * @param {Country} wantedCountry - The country to search for.\r\n * @param {HTMLInputElement} textBox - The textbox element associated with the search.\r\n */\nfunction foundSearch(wantedCountry, textBox) {\n  if (!wantedCountry.getFound()) {\n    const continentIndex = wantedCountry.getCountryLocation()[0];\n    const countryIndex = wantedCountry.getCountryLocation()[1];\n    setCountryIsFoundTo(wantedCountry, true); // Mark the country as found\n    changeColorTo(continentIndex, countryIndex, \"found\"); // Change color of the found country\n    textBox.value = \"\"; // Clear the textbox value\n\n    // Get the 3D object representing the found country\n    const country = allCountries.children[continentIndex].children[countryIndex];\n    const countryPosition = new THREE.Vector3();\n    country.getWorldPosition(countryPosition); // Get the world position of the country\n\n    if (isFollowing) {\n      setCameraPosition(countryPosition); // Set camera position to follow the country\n    }\n    if (countries.isAllFound()) {\n      // Stop the timer when all countries are found\n      timer.stop();\n      // Set the user's score for finding all countries\n      users.setUserScore(currUser.getID(), \"all-basic\", timer.toNumber());\n      console.log(\"Done in \" + timer.toString());\n      timer.reset(); // Reset the timer for the next game\n    }\n  }\n}\n\n/**\r\n * Sets the found status of the given country and increments the count of found countries.\r\n * Also sets the found status for all territories associated with the country.\r\n * @param {Country} wantedCountry - The country to mark as found.\r\n * @param {boolean} found - The new found status.\r\n */\nfunction setCountryIsFoundTo(wantedCountry, found) {\n  wantedCountry.setFound(found); // Set the found status of the main country\n  countries.incrementFound(); // Increment the count of found countries\n\n  // Set found status for all territories associated with the country\n  wantedCountry.getTerritoriesLocation().forEach(location => {\n    if (location !== null) {\n      const country = countries.getCountriesArray()[getIndexFromLocation(location[0], location[1])];\n      country.setFound(true); // Mark territory as found\n      countries.incrementFound(); // Increment the count of found countries\n    }\n  });\n}\n\n/**\r\n * Processes text input to remove unnecessary characters and make it lowercase.\r\n * @param {string} name - The input text.\r\n * @returns {string} The processed text.\r\n */\nfunction processText(name) {\n  name = name.toLowerCase();\n  const fullname = name.split(\" \");\n  name = \"\";\n  for (let i = 0; i < fullname.length; i++) {\n    if (fullname[i][0] !== \"(\") {\n      name += fullname[i];\n    }\n  }\n  return name;\n}\n\n/**\r\n * Handles the checkbox click event to enable/disable country following.\r\n */\nexport function followCountry(event) {\n  const checkbox = event.target;\n  isFollowing = checkbox.checked;\n}\n\n/**\r\n * Handles the mouse move event and intersection with the model.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\nexport function onMouseMove(event) {\n  const mouseX = event.clientX / window.innerWidth * 2 - 1;\n  const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n  const intersects = getIntersect(mouseX, mouseY);\n  if (intersects.length > 0) {\n    const intersectedObject = intersects[0].object;\n    if (isValidObject(intersectedObject)) {\n      updateCountryName(intersectedObject);\n    } else {\n      updateCountryName(null);\n    }\n  } else {\n    updateCountryName(null);\n  }\n}\n\n/**\r\n * Checks if the intersected object is valid (not water or continent boundaries).\r\n * @param {THREE.Object3D} intersectedObject - The intersected object.\r\n * @returns {boolean} True if the object is valid, false otherwise.\r\n */\nfunction isValidObject(intersectedObject) {\n  if (intersectedObject.name === \"water\") return false;\n  const parentObj = intersectedObject.parent;\n  if (!parentObj || parentObj.name === intersectedObject.name.slice(0, parentObj.name.length)) return false;\n  const continentIndex = getIndexFromObject3D(parentObj);\n  const countryIndex = getIndexFromObject3D(intersectedObject);\n  return countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)].getFound() || !getIsPlaying();\n}\n\n/**\r\n * Updates the country name element if it exists.\r\n * @param {THREE.Object3D | null} intersectedObject - The intersected object.\r\n */\nfunction updateCountryName(intersectedObject) {\n  const countryNameElement = document.getElementById(\"country-name\");\n  if (countryNameElement) {\n    if (intersectedObject == null || intersectedObject.parent == null) {\n      countryNameElement.textContent = \"\";\n    } else {\n      const continentIndex = getIndexFromObject3D(intersectedObject.parent);\n      const countryIndex = getIndexFromObject3D(intersectedObject);\n      const country = countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)];\n      countryNameElement.textContent = country.getCountryName(); // Display country name\n    }\n  }\n}\n\n/**\r\n * Changes the color of the selected country on the globe.\r\n * @param {number} continent - The continent index.\r\n * @param {number} index - The index of the country.\r\n * @param {string} colorIndex - The index of the color in the colors array.\r\n */\nfunction changeColorTo(continent, index, colorIndex) {\n  const materialCloned = colorsArray[colorDict[colorIndex]].clone();\n  const connectedLocations = [];\n  const indexLoca = getIndexFromLocation(continent, index);\n  const country = countries.getCountriesArray()[indexLoca];\n  if (!country) {\n    console.error(\"ERROR: country is null\");\n    return;\n  }\n  const ownerLocation = country.getOwnerLocation();\n  if (ownerLocation) {\n    const owner = countries.getCountriesArray()[getIndexFromLocation(ownerLocation[0], ownerLocation[1])];\n    connectedLocations.push(owner.getCountryLocation(), ...owner.getTerritoriesLocation());\n  } else {\n    connectedLocations.push(country.getCountryLocation(), ...country.getTerritoriesLocation());\n  }\n  for (let i = 0; i < connectedLocations.length; i++) {\n    const tempContinentIndex = connectedLocations[i][0];\n    const tempCountryIndex = connectedLocations[i][1];\n    const cap = allCountriesCaps.children[tempContinentIndex].children[tempCountryIndex];\n    const body = allCountries.children[tempContinentIndex].children[tempCountryIndex];\n    if (cap instanceof THREE.Mesh) cap.material = materialCloned;\n    if (body instanceof THREE.Mesh) body.material = materialCloned;\n  }\n  materialCloned.needsUpdate = true;\n}\n\n/**\r\n * Gets the index of the child object within its parent.\r\n * @param {THREE.Object3D} object - The child object.\r\n * @returns {number} The index of the child object within its parent.\r\n */\nfunction getIndexFromObject3D(object) {\n  const parentObj = object.parent;\n  if (!parentObj) return -1;\n  return parentObj.children.findIndex(obj => obj === object);\n}","map":{"version":3,"names":["THREE","Countries","UserSession","createTable","getIndexFromLocation","Timer","loadModel","setupScene","animate","moveModelTo","getIsPlaying","getIsRotating","toggleIsRotating","setCameraPosition","getIntersect","toggleIsPlaying","timer","allCountriesCaps","allCountries","modelParent","globe","currUser","isFollowing","colorsArray","colorDict","unknown","found","unavailable","error","selected","countries","users","renderer","scene","setupModel","loadAndInitializeModel","then","result","console","log","catch","getCountriesArray","children","i","getSize","changeColorTo","getCountryLocation","handleMouseUp","event","button","handleMouseDown","handleTextboxChange","textBox","document","getElementById","reset","start","countryName","processText","value","indexCountry","exists","wantedCountry","foundSearch","getFound","continentIndex","countryIndex","setCountryIsFoundTo","country","countryPosition","Vector3","getWorldPosition","isAllFound","stop","setUserScore","getID","toNumber","toString","setFound","incrementFound","getTerritoriesLocation","forEach","location","name","toLowerCase","fullname","split","length","followCountry","checkbox","target","checked","onMouseMove","mouseX","clientX","window","innerWidth","mouseY","clientY","innerHeight","intersects","intersectedObject","object","isValidObject","updateCountryName","parentObj","parent","slice","getIndexFromObject3D","countryNameElement","textContent","getCountryName","continent","index","colorIndex","materialCloned","clone","connectedLocations","indexLoca","ownerLocation","getOwnerLocation","owner","push","tempContinentIndex","tempCountryIndex","cap","body","Mesh","material","needsUpdate","findIndex","obj"],"sources":["C:/Users/esteb/Documents/GitHub/COTWQ-server/server/client/src/components/ThreeScene.ts"],"sourcesContent":["// ThreeScene.ts\r\n\r\nimport * as THREE from \"three\";\r\nimport { Countries } from \"../models/Countries\";\r\nimport { Country } from \"../models/Country\";\r\nimport { UserModel } from \"../models/UserModel\";\r\nimport { UserSession } from \"../services/UserSession\";\r\nimport { createTable, getIndexFromLocation } from \"../typescripts/countriesTable\";\r\nimport { Timer } from \"../utils/Timer\";\r\nimport { loadModel } from \"../utils/loader\";\r\nimport { setupScene, animate, moveModelTo, getIsPlaying, getIsRotating, toggleIsRotating, setCameraPosition, getIntersect, toggleIsPlaying } from \"../utils/scene\";\r\n\r\n// Create variables\r\nexport let timer: Timer;\r\nlet allCountriesCaps: THREE.Object3D;\r\nlet allCountries: THREE.Object3D;\r\nlet modelParent: THREE.Object3D;\r\nlet globe: THREE.Object3D;\r\nlet currUser: UserModel;\r\nlet isFollowing: boolean = false;\r\nconst colorsArray: THREE.Material[] = [];\r\nconst colorDict: { [key: string]: number } = {\r\n\tunknown: 0,\r\n\tfound: 1,\r\n\tunavailable: 2,\r\n\terror: 3,\r\n\tselected: 4\r\n};\r\nconst countries: Countries = new Countries();\r\nconst users: UserSession = new UserSession();\r\nlet renderer:THREE.WebGLRenderer;\r\nlet scene:THREE.Scene;\r\n//!!!!!! CREATE A SETUP FUNCTION FOR EVERYTHING IN THIS FILE, SO CAN CALL FROM MODEL.TSX\r\n//!? Dunno if necessary anymore\r\nexport function setupModel():void{\r\n\t[renderer, scene] = setupScene(); // Destructure the result of setupScene()\r\n\t\r\n\t// Load and initialize the model\r\n\tloadAndInitializeModel().then((result) => {\r\n\t\tconsole.log(\"Loaded model successfully\");\r\n\t\t// Additional actions to execute after successful resolution\r\n\t})\r\n\t\t.catch((error) => {\r\n\t\t\tconsole.error(\"An error occurred:\", error); // This will execute if the Promise is rejected\r\n\t\t\treturn;\r\n\t\t});\r\n\t\r\n\r\n\tcreateTable(countries.getCountriesArray()); // Create table with countries\r\n\ttimer  = new Timer();\r\n}\r\n\r\n/**\r\n * Asynchronously loads and initializes the 3D model.\r\n */\r\nasync function loadAndInitializeModel(): Promise<void> {\r\n\ttry {\r\n\t\tmodelParent = await loadModel(scene, colorsArray);\r\n\t\tif (!modelParent) {\r\n\t\t\tconsole.error(\"MODEL ERROR: Model is null or undefined.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tanimate(renderer, modelParent); // Start animation\r\n\t\tmoveModelTo(modelParent, 90, null, null); // Move model to the right side of the screen\r\n\t\tglobe = modelParent.children[0];\r\n\t\t\r\n\t\tallCountriesCaps = globe.children[1];\r\n\t\tallCountries = globe.children[0];\r\n\r\n\t\t// Set countries to base color\r\n\t\tfor (let i = 0; i < countries.getSize(); i++) {\r\n\t\t\tchangeColorTo(countries.getCountriesArray()[i].getCountryLocation()[0], countries.getCountriesArray()[i].getCountryLocation()[1], \"unknown\");\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.error(\"An error occurred while loading the model:\", error);\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles the mouse up event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function handleMouseUp(event: MouseEvent): void {\r\n\tif (event.button === 0 && !getIsPlaying() && !getIsRotating()) {\r\n\t\ttoggleIsRotating(); // Toggle rotation if not playing and not rotating\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles the mouse down event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function handleMouseDown(event: MouseEvent): void {\r\n\tif (event.button === 0 && getIsPlaying() && getIsRotating()) {\r\n\t\ttoggleIsRotating(); // Toggle rotation if playing and rotating\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles changes in the textbox input.\r\n */\r\nexport function handleTextboxChange(): void {\r\n\tconst textBox: HTMLInputElement | null = document.getElementById(\"textbox\") as HTMLInputElement;\r\n\r\n\tif (!getIsPlaying()){\r\n\t\ttoggleIsPlaying();\r\n\r\n\t\ttimer.reset();\r\n\t\ttimer.start();\r\n\t}\r\n\tif (textBox) {\r\n\t\tconst countryName: string = processText(textBox.value);\r\n\t\tconst indexCountry: number = countries.exists(countryName);\r\n\r\n\t\tif (indexCountry !== -1) {\r\n\t\t\tconst wantedCountry: Country = countries.getCountriesArray()[indexCountry];\r\n\t\t\tfoundSearch(wantedCountry, textBox);\r\n\t\t\tconsole.log(countries.getFound());\r\n\t\t\tconsole.log(\"Missing: \" + (countries.getSize() - countries.getFound()));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the wanted country is found, changes its status if not found,\r\n * updates its color on the globe, and handles related actions like clearing\r\n * the textbox and setting the camera position.\r\n * @param {Country} wantedCountry - The country to search for.\r\n * @param {HTMLInputElement} textBox - The textbox element associated with the search.\r\n */\r\nfunction foundSearch(wantedCountry: Country, textBox: HTMLInputElement): void {\r\n\tif (!wantedCountry.getFound()) {\r\n\t\tconst continentIndex: number = wantedCountry.getCountryLocation()[0];\r\n\t\tconst countryIndex: number = wantedCountry.getCountryLocation()[1];\r\n\r\n\t\tsetCountryIsFoundTo(wantedCountry, true); // Mark the country as found\r\n\t\tchangeColorTo(continentIndex, countryIndex, \"found\"); // Change color of the found country\r\n\t\ttextBox.value = \"\"; // Clear the textbox value\r\n\r\n\t\t// Get the 3D object representing the found country\r\n\t\tconst country: THREE.Object3D = allCountries.children[continentIndex].children[countryIndex];\r\n\r\n\t\tconst countryPosition: THREE.Vector3 = new THREE.Vector3();\r\n\t\tcountry.getWorldPosition(countryPosition); // Get the world position of the country\r\n\r\n\t\tif (isFollowing) {\r\n\t\t\tsetCameraPosition(countryPosition); // Set camera position to follow the country\r\n\t\t}\r\n\r\n\t\tif (countries.isAllFound()) {\r\n\t\t\t// Stop the timer when all countries are found\r\n\t\t\ttimer.stop();\r\n\t\t\t// Set the user's score for finding all countries\r\n\t\t\tusers.setUserScore(currUser.getID(), \"all-basic\", timer.toNumber());\r\n\t\t\tconsole.log(\"Done in \" + timer.toString());\r\n\t\t\ttimer.reset(); // Reset the timer for the next game\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Sets the found status of the given country and increments the count of found countries.\r\n * Also sets the found status for all territories associated with the country.\r\n * @param {Country} wantedCountry - The country to mark as found.\r\n * @param {boolean} found - The new found status.\r\n */\r\nfunction setCountryIsFoundTo(wantedCountry: Country, found: boolean): void {\r\n\twantedCountry.setFound(found); // Set the found status of the main country\r\n\tcountries.incrementFound(); // Increment the count of found countries\r\n\r\n\t// Set found status for all territories associated with the country\r\n\twantedCountry.getTerritoriesLocation().forEach((location: number[]) => {\r\n\t\tif (location !== null) {\r\n\t\t\tconst country: Country = countries.getCountriesArray()[getIndexFromLocation(location[0], location[1])];\r\n\t\t\tcountry.setFound(true); // Mark territory as found\r\n\t\t\tcountries.incrementFound(); // Increment the count of found countries\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Processes text input to remove unnecessary characters and make it lowercase.\r\n * @param {string} name - The input text.\r\n * @returns {string} The processed text.\r\n */\r\nfunction processText(name: string): string {\r\n\tname = name.toLowerCase();\r\n\tconst fullname: string[] = name.split(\" \");\r\n\tname = \"\";\r\n\r\n\tfor (let i = 0; i < fullname.length; i++) {\r\n\t\tif (fullname[i][0] !== \"(\") {\r\n\t\t\tname += fullname[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn name;\r\n}\r\n\r\n/**\r\n * Handles the checkbox click event to enable/disable country following.\r\n */\r\nexport function followCountry(event: React.ChangeEvent<HTMLInputElement>): void{\r\n\tconst checkbox: HTMLInputElement = event.target;\r\n\tisFollowing = checkbox.checked;\r\n  }\r\n\r\n/**\r\n * Handles the mouse move event and intersection with the model.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function onMouseMove(event: MouseEvent): void {\r\n\tconst mouseX: number = (event.clientX / window.innerWidth) * 2 - 1;\r\n\tconst mouseY: number = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\tconst intersects: THREE.Intersection[] = getIntersect(mouseX, mouseY);\r\n\r\n\tif (intersects.length > 0) {\r\n\t\tconst intersectedObject: THREE.Object3D = intersects[0].object;\r\n\t\tif (isValidObject(intersectedObject)) {\r\n\t\t\tupdateCountryName(intersectedObject);\r\n\t\t} else{\r\n\t\t\tupdateCountryName(null);\r\n\t\t}\r\n\t} else {\r\n\t\tupdateCountryName(null);\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the intersected object is valid (not water or continent boundaries).\r\n * @param {THREE.Object3D} intersectedObject - The intersected object.\r\n * @returns {boolean} True if the object is valid, false otherwise.\r\n */\r\nfunction isValidObject(intersectedObject: THREE.Object3D): boolean {\r\n\tif (intersectedObject.name === \"water\") return false;\r\n\tconst parentObj: THREE.Object3D | null = intersectedObject.parent;\r\n\r\n\tif (!parentObj || parentObj.name === intersectedObject.name.slice(0, parentObj.name.length)) return false;\r\n\r\n\tconst continentIndex: number = getIndexFromObject3D(parentObj);\r\n\tconst countryIndex: number = getIndexFromObject3D(intersectedObject);\r\n\treturn countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)].getFound() || !getIsPlaying();\r\n}\r\n\r\n/**\r\n * Updates the country name element if it exists.\r\n * @param {THREE.Object3D | null} intersectedObject - The intersected object.\r\n */\r\nfunction updateCountryName(intersectedObject: THREE.Object3D | null): void {\r\n\tconst countryNameElement: HTMLElement | null = document.getElementById(\"country-name\");\r\n\tif (countryNameElement) {\r\n\t\tif (intersectedObject == null || intersectedObject.parent == null) {\r\n\t\t\tcountryNameElement.textContent = \"\";\r\n\t\t} else {\r\n\t\t\tconst continentIndex: number = getIndexFromObject3D(intersectedObject.parent);\r\n\t\t\tconst countryIndex: number = getIndexFromObject3D(intersectedObject);\r\n\t\t\tconst country: Country = countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)];\r\n\t\t\tcountryNameElement.textContent = country.getCountryName(); // Display country name\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Changes the color of the selected country on the globe.\r\n * @param {number} continent - The continent index.\r\n * @param {number} index - The index of the country.\r\n * @param {string} colorIndex - The index of the color in the colors array.\r\n */\r\nfunction changeColorTo(continent: number, index: number, colorIndex: string): void {\r\n\tconst materialCloned: THREE.Material = colorsArray[colorDict[colorIndex]].clone();\r\n\tconst connectedLocations: number[][] = [];\r\n\r\n\tconst indexLoca = getIndexFromLocation(continent, index);\r\n\tconst country: Country | null = countries.getCountriesArray()[indexLoca];\r\n\r\n\tif (!country) {\r\n\t\tconsole.error(\"ERROR: country is null\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst ownerLocation: number[] | null = country.getOwnerLocation();\r\n\tif (ownerLocation) {\r\n\t\tconst owner: Country = countries.getCountriesArray()[getIndexFromLocation(ownerLocation[0], ownerLocation[1])];\r\n\t\tconnectedLocations.push(owner.getCountryLocation(), ...owner.getTerritoriesLocation());\r\n\t} else {\r\n\t\tconnectedLocations.push(country.getCountryLocation(), ...country.getTerritoriesLocation());\r\n\t}\r\n\t\r\n\r\n\tfor (let i = 0; i < connectedLocations.length; i++) {\r\n\t\tconst tempContinentIndex: number = connectedLocations[i][0];\r\n\t\tconst tempCountryIndex: number = connectedLocations[i][1];\r\n\r\n\t\tconst cap: THREE.Object3D = allCountriesCaps.children[tempContinentIndex].children[tempCountryIndex];\r\n\t\tconst body: THREE.Object3D = allCountries.children[tempContinentIndex].children[tempCountryIndex];\r\n\r\n\t\tif (cap instanceof THREE.Mesh) cap.material = materialCloned;\r\n\t\tif (body instanceof THREE.Mesh) body.material = materialCloned;\r\n\t}\r\n\r\n\tmaterialCloned.needsUpdate = true;\r\n}\r\n\r\n/**\r\n * Gets the index of the child object within its parent.\r\n * @param {THREE.Object3D} object - The child object.\r\n * @returns {number} The index of the child object within its parent.\r\n */\r\nfunction getIndexFromObject3D(object: THREE.Object3D): number {\r\n\tconst parentObj: THREE.Object3D | null = object.parent;\r\n\tif (!parentObj) return -1;\r\n\treturn parentObj.children.findIndex(obj => obj === object);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}