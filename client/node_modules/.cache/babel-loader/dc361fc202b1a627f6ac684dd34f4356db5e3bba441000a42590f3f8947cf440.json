{"ast":null,"code":"// ThreeScene.ts\n\nimport * as THREE from \"three\";\nimport { Countries } from \"../models/Countries\";\nimport { createTable, getIndexFromLocation } from \"../typescripts/countriesTable\";\nimport { loadModel } from \"../utils/loader\";\nimport { setupScene, animate, moveModelTo, getIsPlaying, getIsRotating, toggleIsRotating, setCameraPosition, getIntersect } from \"../utils/scene\";\n// Create variables\nlet allCountriesCaps;\nlet allCountries;\nlet modelParent;\nlet globe;\nlet isFollowing = false;\nconst colorsArray = [];\nconst colorDict = {\n  unknown: 0,\n  found: 1,\n  unavailable: 2,\n  error: 3,\n  selected: 4\n};\nconst countries = new Countries();\nlet renderer;\nlet scene;\n//!!!!!! CREATE A SETUP FUNCTION FOR EVERYTHING IN THIS FILE, SO CAN CALL FROM MODEL.TSX\n//!? Dunno if necessary anymore\nexport function setupModel() {\n  [renderer, scene] = setupScene(); // Destructure the result of setupScene()\n\n  // Load and initialize the model\n  loadAndInitializeModel().then(result => {\n    console.log(\"Loaded model successfully\");\n    // Additional actions to execute after successful resolution\n  }).catch(error => {\n    console.error(\"An error occurred:\", error); // This will execute if the Promise is rejected\n    return;\n  });\n  createTable(countries.getCountriesArray()); // Create table with countries\n}\n\n/**\r\n * Asynchronously loads and initializes the 3D model.\r\n */\nasync function loadAndInitializeModel() {\n  try {\n    modelParent = await loadModel(scene, colorsArray);\n    if (!modelParent) {\n      console.error(\"MODEL ERROR: Model is null or undefined.\");\n      return;\n    }\n    animate(renderer, modelParent); // Start animation\n    moveModelTo(modelParent, 90, null, null); // Move model to the right side of the screen\n    globe = modelParent.children[0];\n    allCountriesCaps = globe.children[1];\n    allCountries = globe.children[0];\n\n    // Set countries to base color\n    for (let i = 0; i < countries.getSize(); i++) {\n      changeColorTo(countries.getCountriesArray()[i].getCountryLocation()[0], countries.getCountriesArray()[i].getCountryLocation()[1], \"unknown\");\n    }\n  } catch (error) {\n    console.error(\"An error occurred while loading the model:\", error);\n  }\n}\n\n/**\r\n * Handles the mouse up event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\nexport function handleMouseUp(event) {\n  if (event.button === 0 && !getIsPlaying() && !getIsRotating()) {\n    toggleIsRotating(); // Toggle rotation if not playing and not rotating\n  }\n}\n\n/**\r\n * Handles the mouse down event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\nexport function handleMouseDown(event) {\n  if (event.button === 0 && getIsPlaying() && getIsRotating()) {\n    toggleIsRotating(); // Toggle rotation if playing and rotating\n  }\n}\n\n/**\r\n * Handles changes in the textbox input.\r\n */\nexport function handleTextboxChange(_event, timer) {\n  const textBox = document.getElementById(\"textbox\");\n  const countryCounterDiv = document.getElementById(\"country-counter\");\n  if (textBox && timer) {\n    const countryName = processText(textBox.value);\n    const indexCountry = countries.exists(countryName);\n    if (indexCountry !== -1) {\n      const wantedCountry = countries.getCountriesArray()[indexCountry];\n      if (foundSearch(wantedCountry, textBox)) {\n        timer.stop();\n      }\n      countryCounterDiv.textContent = String(countries.getFound());\n    }\n  }\n}\n\n/**\r\n * Checks if the wanted country is found, changes its status if not found,\r\n * updates its color on the globe, and handles related actions like clearing\r\n * the textbox and setting the camera position.\r\n * @param {Country} wantedCountry - The country to search for.\r\n * @param {HTMLInputElement} textBox - The textbox element associated with the search.\r\n */\nfunction foundSearch(wantedCountry, textBox) {\n  if (!wantedCountry.getFound()) {\n    const continentIndex = wantedCountry.getCountryLocation()[0];\n    const countryIndex = wantedCountry.getCountryLocation()[1];\n    setCountryIsFoundTo(wantedCountry, true); // Mark the country as found\n    changeColorTo(continentIndex, countryIndex, \"found\"); // Change color of the found country\n    textBox.value = \"\"; // Clear the textbox value\n\n    // Get the 3D object representing the found country\n    const country = allCountries.children[continentIndex].children[countryIndex];\n    const countryPosition = new THREE.Vector3();\n    country.getWorldPosition(countryPosition); // Get the world position of the country\n\n    if (isFollowing) {\n      setCameraPosition(countryPosition); // Set camera position to follow the country\n    }\n  }\n  return countries.isAllFound();\n}\n\n/**\r\n * Sets the found status of the given country and increments the count of found countries.\r\n * Also sets the found status for all territories associated with the country.\r\n * @param {Country} wantedCountry - The country to mark as found.\r\n * @param {boolean} found - The new found status.\r\n */\nfunction setCountryIsFoundTo(wantedCountry, found) {\n  wantedCountry.setFound(found); // Set the found status of the main country\n  countries.incrementFound(); // Increment the count of found countries\n\n  // Set found status for all territories associated with the country\n  wantedCountry.getTerritoriesLocation().forEach(location => {\n    if (location !== null) {\n      const country = countries.getCountriesArray()[getIndexFromLocation(location[0], location[1])];\n      country.setFound(true); // Mark territory as found\n    }\n  });\n}\n\n/**\r\n * Processes text input to remove unnecessary characters and make it lowercase.\r\n * @param {string} name - The input text.\r\n * @returns {string} The processed text.\r\n */\nfunction processText(name) {\n  name = name.toLowerCase();\n  const fullname = name.split(\" \");\n  name = \"\";\n  for (let i = 0; i < fullname.length; i++) {\n    if (fullname[i][0] !== \"(\") {\n      name += fullname[i];\n    }\n  }\n  return name;\n}\n\n/**\r\n * Handles the checkbox click event to enable/disable country following.\r\n */\nexport function followCountry(event) {\n  const checkbox = event.target;\n  isFollowing = checkbox.checked;\n}\n\n/**\r\n * Handles the mouse move event and intersection with the model.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\nexport function onMouseMove(event) {\n  const mouseX = event.clientX / window.innerWidth * 2 - 1;\n  const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n  const intersects = getIntersect(mouseX, mouseY);\n  if (intersects.length > 0) {\n    const intersectedObject = intersects[0].object;\n    if (isValidObject(intersectedObject)) {\n      updateCountryName(intersectedObject);\n    } else {\n      updateCountryName(null);\n    }\n  } else {\n    updateCountryName(null);\n  }\n}\n\n/**\r\n * Checks if the intersected object is valid (not water or continent boundaries).\r\n * @param {THREE.Object3D} intersectedObject - The intersected object.\r\n * @returns {boolean} True if the object is valid, false otherwise.\r\n */\nfunction isValidObject(intersectedObject) {\n  if (intersectedObject.name === \"water\") return false;\n  const parentObj = intersectedObject.parent;\n  if (!parentObj || parentObj.name === intersectedObject.name.slice(0, parentObj.name.length)) return false;\n  const continentIndex = getIndexFromObject3D(parentObj);\n  const countryIndex = getIndexFromObject3D(intersectedObject);\n  return countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)].getFound() || !getIsPlaying();\n}\n\n/**\r\n * Updates the country name element if it exists.\r\n * @param {THREE.Object3D | null} intersectedObject - The intersected object.\r\n */\nfunction updateCountryName(intersectedObject) {\n  const countryNameElement = document.getElementById(\"country-name-container\");\n  if (countryNameElement) {\n    if (intersectedObject == null || intersectedObject.parent == null) {\n      countryNameElement.textContent = \"\";\n    } else {\n      const continentIndex = getIndexFromObject3D(intersectedObject.parent);\n      const countryIndex = getIndexFromObject3D(intersectedObject);\n      const country = countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)];\n      countryNameElement.textContent = country.getCountryName(); // Display country name\n    }\n  }\n}\n\n/**\r\n * Changes the color of the selected country on the globe.\r\n * @param {number} continent - The continent index.\r\n * @param {number} index - The index of the country.\r\n * @param {string} colorIndex - The index of the color in the colors array.\r\n */\nfunction changeColorTo(continent, index, colorIndex) {\n  const materialCloned = colorsArray[colorDict[colorIndex]].clone();\n  const connectedLocations = [];\n  const indexLoca = getIndexFromLocation(continent, index);\n  const country = countries.getCountriesArray()[indexLoca];\n  if (!country) {\n    console.error(\"ERROR: country is null\");\n    return;\n  }\n  const ownerLocation = country.getOwnerLocation();\n  if (ownerLocation) {\n    const owner = countries.getCountriesArray()[getIndexFromLocation(ownerLocation[0], ownerLocation[1])];\n    connectedLocations.push(owner.getCountryLocation(), ...owner.getTerritoriesLocation());\n  } else {\n    connectedLocations.push(country.getCountryLocation(), ...country.getTerritoriesLocation());\n  }\n  for (let i = 0; i < connectedLocations.length; i++) {\n    const tempContinentIndex = connectedLocations[i][0];\n    const tempCountryIndex = connectedLocations[i][1];\n    const cap = allCountriesCaps.children[tempContinentIndex].children[tempCountryIndex];\n    const body = allCountries.children[tempContinentIndex].children[tempCountryIndex];\n    if (cap instanceof THREE.Mesh) cap.material = materialCloned;\n    if (body instanceof THREE.Mesh) body.material = materialCloned;\n  }\n  materialCloned.needsUpdate = true;\n}\n\n/**\r\n * Gets the index of the child object within its parent.\r\n * @param {THREE.Object3D} object - The child object.\r\n * @returns {number} The index of the child object within its parent.\r\n */\nfunction getIndexFromObject3D(object) {\n  const parentObj = object.parent;\n  if (!parentObj) return -1;\n  return parentObj.children.findIndex(obj => obj === object);\n}","map":{"version":3,"names":["THREE","Countries","createTable","getIndexFromLocation","loadModel","setupScene","animate","moveModelTo","getIsPlaying","getIsRotating","toggleIsRotating","setCameraPosition","getIntersect","allCountriesCaps","allCountries","modelParent","globe","isFollowing","colorsArray","colorDict","unknown","found","unavailable","error","selected","countries","renderer","scene","setupModel","loadAndInitializeModel","then","result","console","log","catch","getCountriesArray","children","i","getSize","changeColorTo","getCountryLocation","handleMouseUp","event","button","handleMouseDown","handleTextboxChange","_event","timer","textBox","document","getElementById","countryCounterDiv","countryName","processText","value","indexCountry","exists","wantedCountry","foundSearch","stop","textContent","String","getFound","continentIndex","countryIndex","setCountryIsFoundTo","country","countryPosition","Vector3","getWorldPosition","isAllFound","setFound","incrementFound","getTerritoriesLocation","forEach","location","name","toLowerCase","fullname","split","length","followCountry","checkbox","target","checked","onMouseMove","mouseX","clientX","window","innerWidth","mouseY","clientY","innerHeight","intersects","intersectedObject","object","isValidObject","updateCountryName","parentObj","parent","slice","getIndexFromObject3D","countryNameElement","getCountryName","continent","index","colorIndex","materialCloned","clone","connectedLocations","indexLoca","ownerLocation","getOwnerLocation","owner","push","tempContinentIndex","tempCountryIndex","cap","body","Mesh","material","needsUpdate","findIndex","obj"],"sources":["C:/Users/esteb/Documents/GitHub/COTWQ-server/client/src/components/ThreeScene.ts"],"sourcesContent":["// ThreeScene.ts\r\n\r\nimport * as THREE from \"three\";\r\nimport { Countries } from \"../models/Countries\";\r\nimport { Country } from \"../models/Country\";\r\nimport { createTable, getIndexFromLocation } from \"../typescripts/countriesTable\";\r\nimport { loadModel } from \"../utils/loader\";\r\nimport { setupScene, animate, moveModelTo, getIsPlaying, getIsRotating, toggleIsRotating, setCameraPosition, getIntersect } from \"../utils/scene\";\r\nimport { Timer } from \"../utils/Timer\";\r\n\r\n// Create variables\r\nlet allCountriesCaps: THREE.Object3D;\r\nlet allCountries: THREE.Object3D;\r\nlet modelParent: THREE.Object3D;\r\nlet globe: THREE.Object3D;\r\nlet isFollowing: boolean = false;\r\nconst colorsArray: THREE.Material[] = [];\r\nconst colorDict: { [key: string]: number } = {\r\n\tunknown: 0,\r\n\tfound: 1,\r\n\tunavailable: 2,\r\n\terror: 3,\r\n\tselected: 4\r\n};\r\nconst countries: Countries = new Countries();\r\nlet renderer:THREE.WebGLRenderer;\r\nlet scene:THREE.Scene;\r\n//!!!!!! CREATE A SETUP FUNCTION FOR EVERYTHING IN THIS FILE, SO CAN CALL FROM MODEL.TSX\r\n//!? Dunno if necessary anymore\r\nexport function setupModel():void{\r\n\t[renderer, scene] = setupScene(); // Destructure the result of setupScene()\r\n\t\r\n\t// Load and initialize the model\r\n\tloadAndInitializeModel().then((result) => {\r\n\t\tconsole.log(\"Loaded model successfully\");\r\n\t\t// Additional actions to execute after successful resolution\r\n\t}).catch((error) => {\r\n\t\tconsole.error(\"An error occurred:\", error); // This will execute if the Promise is rejected\r\n\t\treturn;\r\n\t});\r\n\t\r\n\r\n\tcreateTable(countries.getCountriesArray()); // Create table with countries\r\n}\r\n\r\n/**\r\n * Asynchronously loads and initializes the 3D model.\r\n */\r\nasync function loadAndInitializeModel(): Promise<void> {\r\n\ttry {\r\n\t\tmodelParent = await loadModel(scene, colorsArray);\r\n\t\tif (!modelParent) {\r\n\t\t\tconsole.error(\"MODEL ERROR: Model is null or undefined.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tanimate(renderer, modelParent); // Start animation\r\n\t\tmoveModelTo(modelParent, 90, null, null); // Move model to the right side of the screen\r\n\t\tglobe = modelParent.children[0];\r\n\t\t\r\n\t\tallCountriesCaps = globe.children[1];\r\n\t\tallCountries = globe.children[0];\r\n\r\n\t\t// Set countries to base color\r\n\t\tfor (let i = 0; i < countries.getSize(); i++) {\r\n\t\t\tchangeColorTo(countries.getCountriesArray()[i].getCountryLocation()[0], countries.getCountriesArray()[i].getCountryLocation()[1], \"unknown\");\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.error(\"An error occurred while loading the model:\", error);\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles the mouse up event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function handleMouseUp(event: MouseEvent): void {\r\n\tif (event.button === 0 && !getIsPlaying() && !getIsRotating()) {\r\n\t\ttoggleIsRotating(); // Toggle rotation if not playing and not rotating\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles the mouse down event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function handleMouseDown(event: MouseEvent): void {\r\n\tif (event.button === 0 && getIsPlaying() && getIsRotating()) {\r\n\t\ttoggleIsRotating(); // Toggle rotation if playing and rotating\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles changes in the textbox input.\r\n */\r\nexport function handleTextboxChange(_event:React.FormEvent<HTMLInputElement>, timer:Timer|null): void {\r\n\tconst textBox: HTMLInputElement | null = document.getElementById(\"textbox\") as HTMLInputElement;\r\n\tconst countryCounterDiv:HTMLDivElement|null = document.getElementById(\"country-counter\") as HTMLDivElement;\r\n\r\n\tif (textBox && timer) {\r\n\t\tconst countryName: string = processText(textBox.value);\r\n\t\tconst indexCountry: number = countries.exists(countryName);\r\n\r\n\t\tif (indexCountry !== -1) {\r\n\t\t\tconst wantedCountry: Country = countries.getCountriesArray()[indexCountry];\r\n\t\t\tif (foundSearch(wantedCountry, textBox)){\r\n\t\t\t\ttimer.stop();\r\n\t\t\t}\r\n\t\t\tcountryCounterDiv.textContent= String(countries.getFound());\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the wanted country is found, changes its status if not found,\r\n * updates its color on the globe, and handles related actions like clearing\r\n * the textbox and setting the camera position.\r\n * @param {Country} wantedCountry - The country to search for.\r\n * @param {HTMLInputElement} textBox - The textbox element associated with the search.\r\n */\r\nfunction foundSearch(wantedCountry: Country, textBox: HTMLInputElement): boolean {\r\n\tif (!wantedCountry.getFound()) {\r\n\t\tconst continentIndex: number = wantedCountry.getCountryLocation()[0];\r\n\t\tconst countryIndex: number = wantedCountry.getCountryLocation()[1];\r\n\r\n\t\tsetCountryIsFoundTo(wantedCountry, true); // Mark the country as found\r\n\t\tchangeColorTo(continentIndex, countryIndex, \"found\"); // Change color of the found country\r\n\t\ttextBox.value = \"\"; // Clear the textbox value\r\n\r\n\t\t// Get the 3D object representing the found country\r\n\t\tconst country: THREE.Object3D = allCountries.children[continentIndex].children[countryIndex];\r\n\r\n\t\tconst countryPosition: THREE.Vector3 = new THREE.Vector3();\r\n\t\tcountry.getWorldPosition(countryPosition); // Get the world position of the country\r\n\r\n\t\tif (isFollowing) {\r\n\t\t\tsetCameraPosition(countryPosition); // Set camera position to follow the country\r\n\t\t}\t\r\n\t}\r\n\r\n\treturn countries.isAllFound();\r\n}\r\n\r\n\r\n/**\r\n * Sets the found status of the given country and increments the count of found countries.\r\n * Also sets the found status for all territories associated with the country.\r\n * @param {Country} wantedCountry - The country to mark as found.\r\n * @param {boolean} found - The new found status.\r\n */\r\nfunction setCountryIsFoundTo(wantedCountry: Country, found: boolean): void {\r\n\twantedCountry.setFound(found); // Set the found status of the main country\r\n\tcountries.incrementFound(); // Increment the count of found countries\r\n\r\n\t// Set found status for all territories associated with the country\r\n\twantedCountry.getTerritoriesLocation().forEach((location: number[]) => {\r\n\t\tif (location !== null) {\r\n\t\t\tconst country: Country = countries.getCountriesArray()[getIndexFromLocation(location[0], location[1])];\r\n\t\t\tcountry.setFound(true); // Mark territory as found\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Processes text input to remove unnecessary characters and make it lowercase.\r\n * @param {string} name - The input text.\r\n * @returns {string} The processed text.\r\n */\r\nfunction processText(name: string): string {\r\n\tname = name.toLowerCase();\r\n\tconst fullname: string[] = name.split(\" \");\r\n\tname = \"\";\r\n\r\n\tfor (let i = 0; i < fullname.length; i++) {\r\n\t\tif (fullname[i][0] !== \"(\") {\r\n\t\t\tname += fullname[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn name;\r\n}\r\n\r\n/**\r\n * Handles the checkbox click event to enable/disable country following.\r\n */\r\nexport function followCountry(event: React.ChangeEvent<HTMLInputElement>): void{\r\n\tconst checkbox: HTMLInputElement = event.target;\r\n\tisFollowing = checkbox.checked;\r\n  }\r\n\r\n/**\r\n * Handles the mouse move event and intersection with the model.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function onMouseMove(event: MouseEvent): void {\r\n\tconst mouseX: number = (event.clientX / window.innerWidth) * 2 - 1;\r\n\tconst mouseY: number = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\tconst intersects: THREE.Intersection[] = getIntersect(mouseX, mouseY);\r\n\r\n\tif (intersects.length > 0) {\r\n\t\tconst intersectedObject: THREE.Object3D = intersects[0].object;\r\n\t\tif (isValidObject(intersectedObject)) {\r\n\t\t\tupdateCountryName(intersectedObject);\r\n\t\t} else{\r\n\t\t\tupdateCountryName(null);\r\n\t\t}\r\n\t} else {\r\n\t\tupdateCountryName(null);\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the intersected object is valid (not water or continent boundaries).\r\n * @param {THREE.Object3D} intersectedObject - The intersected object.\r\n * @returns {boolean} True if the object is valid, false otherwise.\r\n */\r\nfunction isValidObject(intersectedObject: THREE.Object3D): boolean {\r\n\tif (intersectedObject.name === \"water\") return false;\r\n\tconst parentObj: THREE.Object3D | null = intersectedObject.parent;\r\n\r\n\tif (!parentObj || parentObj.name === intersectedObject.name.slice(0, parentObj.name.length)) return false;\r\n\r\n\tconst continentIndex: number = getIndexFromObject3D(parentObj);\r\n\tconst countryIndex: number = getIndexFromObject3D(intersectedObject);\r\n\treturn countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)].getFound() || !getIsPlaying();\r\n}\r\n\r\n/**\r\n * Updates the country name element if it exists.\r\n * @param {THREE.Object3D | null} intersectedObject - The intersected object.\r\n */\r\nfunction updateCountryName(intersectedObject: THREE.Object3D | null): void {\r\n\tconst countryNameElement: HTMLElement | null = document.getElementById(\"country-name-container\");\r\n\tif (countryNameElement) {\r\n\t\tif (intersectedObject == null || intersectedObject.parent == null) {\r\n\t\t\tcountryNameElement.textContent = \"\";\r\n\t\t} else {\r\n\t\t\tconst continentIndex: number = getIndexFromObject3D(intersectedObject.parent);\r\n\t\t\tconst countryIndex: number = getIndexFromObject3D(intersectedObject);\r\n\t\t\tconst country: Country = countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)];\r\n\t\t\tcountryNameElement.textContent = country.getCountryName(); // Display country name\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Changes the color of the selected country on the globe.\r\n * @param {number} continent - The continent index.\r\n * @param {number} index - The index of the country.\r\n * @param {string} colorIndex - The index of the color in the colors array.\r\n */\r\nfunction changeColorTo(continent: number, index: number, colorIndex: string): void {\r\n\tconst materialCloned: THREE.Material = colorsArray[colorDict[colorIndex]].clone();\r\n\tconst connectedLocations: number[][] = [];\r\n\r\n\tconst indexLoca = getIndexFromLocation(continent, index);\r\n\tconst country: Country | null = countries.getCountriesArray()[indexLoca];\r\n\r\n\tif (!country) {\r\n\t\tconsole.error(\"ERROR: country is null\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst ownerLocation: number[] | null = country.getOwnerLocation();\r\n\tif (ownerLocation) {\r\n\t\tconst owner: Country = countries.getCountriesArray()[getIndexFromLocation(ownerLocation[0], ownerLocation[1])];\r\n\t\tconnectedLocations.push(owner.getCountryLocation(), ...owner.getTerritoriesLocation());\r\n\t} else {\r\n\t\tconnectedLocations.push(country.getCountryLocation(), ...country.getTerritoriesLocation());\r\n\t}\r\n\t\r\n\r\n\tfor (let i = 0; i < connectedLocations.length; i++) {\r\n\t\tconst tempContinentIndex: number = connectedLocations[i][0];\r\n\t\tconst tempCountryIndex: number = connectedLocations[i][1];\r\n\r\n\t\tconst cap: THREE.Object3D = allCountriesCaps.children[tempContinentIndex].children[tempCountryIndex];\r\n\t\tconst body: THREE.Object3D = allCountries.children[tempContinentIndex].children[tempCountryIndex];\r\n\r\n\t\tif (cap instanceof THREE.Mesh) cap.material = materialCloned;\r\n\t\tif (body instanceof THREE.Mesh) body.material = materialCloned;\r\n\t}\r\n\r\n\tmaterialCloned.needsUpdate = true;\r\n}\r\n\r\n/**\r\n * Gets the index of the child object within its parent.\r\n * @param {THREE.Object3D} object - The child object.\r\n * @returns {number} The index of the child object within its parent.\r\n */\r\nfunction getIndexFromObject3D(object: THREE.Object3D): number {\r\n\tconst parentObj: THREE.Object3D | null = object.parent;\r\n\tif (!parentObj) return -1;\r\n\treturn parentObj.children.findIndex(obj => obj === object);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}