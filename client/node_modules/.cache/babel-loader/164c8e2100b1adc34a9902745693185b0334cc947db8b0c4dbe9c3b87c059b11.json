{"ast":null,"code":"// scene.ts\nimport*as THREE from\"three\";import{OrbitControls}from\"three/examples/jsm/controls/OrbitControls\";import{Tween,Easing,update}from'@tweenjs/tween.js';// Define variables\nlet isRotating=true;let isPlaying=false;let myModel;let lastRenderTime=0;const minDistance=70;let controls;let camera;let scene;let hemisphereLight;/**\r\n * Sets up the scene by creating a renderer, scene, camera, controls, and\r\n * directional light.\r\n * @returns An array containing the renderer and scene.\r\n */export function setupScene(){// Get a reference to the canvas element\nconst canvas=document.getElementById(\"modelCanvas\");// Ensure the canvas element exists\nif(!canvas){console.error(\"Canvas element 'modelCanvas' not found.\");// Handle the error or provide a fallback\n}// Create a WebGL renderer and set its size to match the canvas\nconst renderer=new THREE.WebGLRenderer({canvas});renderer.setSize(canvas.clientWidth,canvas.clientHeight);document.body.appendChild(renderer.domElement);// Create the scene\nscene=new THREE.Scene();// Create the camera\ncamera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);camera.position.set(0,0,140);// Create the controls\ncontrols=new OrbitControls(camera,renderer.domElement);controls.rotateSpeed=0.5;controls.zoomSpeed=0.5;controls.panSpeed=0.5;controls.enablePan=false;controls.enableDamping=true;controls.enabled=isPlaying;// Add directional light\nhemisphereLight=new THREE.HemisphereLight(0xffffff,0.7);scene.add(hemisphereLight);return[renderer,scene];}/**\r\n * Animates the scene.\r\n * @param {THREE.WebGLRenderer} renderer - The WebGL renderer.\r\n * @param {THREE.Object3D} model - The 3D object representing the model.\r\n */export function animate(renderer,model){myModel=model;function _animate(currentTime){const delta=currentTime-lastRenderTime;const cameraPosition=new THREE.Vector3();camera.getWorldPosition(cameraPosition);const distanceToCenter=cameraPosition.length();if(isRotating){myModel.rotation.y+=0.0005;}if(distanceToCenter<minDistance){const directionToCenter=cameraPosition.clone().normalize();const newCameraPosition=directionToCenter.multiplyScalar(minDistance);camera.position.copy(newCameraPosition);}hemisphereLight.position.copy(cameraPosition);if(delta>=16){controls.update();renderer.render(scene,camera);lastRenderTime=currentTime;}requestAnimationFrame(_animate);update();}_animate(0);}/**\r\n * Updates the state of controls based on the `isPlaying` flag.\r\n */function updateControls(){controls.enabled=isPlaying;}/**\r\n * Toggles the `isPlaying` flag.\r\n */export function toggleIsPlaying(){isPlaying=!isPlaying;if(isPlaying){moveModelTo(myModel,0,null,null);if(isRotating)toggleIsRotating();}else{moveModelTo(myModel,90,null,null);if(!isRotating)toggleIsRotating();}updateControls();// Call updateControls to ensure controls are updated\n}/**\r\n * Toggles the `isRotating` flag.\r\n */export function toggleIsRotating(){isRotating=!isRotating;}/**\r\n * Gets intersections of a raycaster with objects in the scene based on mouse coordinates.\r\n * @param {number} mouseX - The X coordinate of the mouse.\r\n * @param {number} mouseY - The Y coordinate of the mouse.\r\n * @returns {THREE.Intersection[]} An array of intersections.\r\n */export function getIntersect(mouseX,mouseY){// Create a raycaster\nconst raycaster=new THREE.Raycaster();// Set raycaster origin as mouse position in NDC using Vector2\nconst mouseVector=new THREE.Vector2(mouseX,mouseY);raycaster.setFromCamera(mouseVector,camera);// Perform raycasting\nreturn raycaster.intersectObjects(scene.children,true);}/**\r\n * Moves the model to the specified position.\r\n * @param {THREE.Object3D} model - The 3D object representing the model.\r\n * @param {number | null} x - The X coordinate of the new position.\r\n * @param {number | null} y - The Y coordinate of the new position.\r\n * @param {number | null} z - The Z coordinate of the new position.\r\n */export function moveModelTo(model,x,y,z){const targetPosition={x:x!==null?x:model.position.x,y:y!==null?y:model.position.y,z:z!==null?z:model.position.z};new Tween(model.position).to(targetPosition,1500).easing(Easing.Quadratic.Out).start();}/**\r\n * Sets the camera position to the specified vector.\r\n * @param {THREE.Vector3} vector - The new camera position.\r\n */export function setCameraPosition(vector){const cameraPosition=new THREE.Vector3();camera.getWorldPosition(cameraPosition);const directionToCenter=vector.clone().normalize();const newCameraPosition=directionToCenter.multiplyScalar(cameraPosition.length());// camera.position.copy(newCameraPosition);\nnew Tween(cameraPosition).to(newCameraPosition,1000).easing(Easing.Linear.In).onUpdate(()=>{camera.position.copy(cameraPosition);camera.lookAt(directionToCenter);}).start();}/**\r\n * Returns the value of the `isPlaying` flag.\r\n * @returns {boolean} The value of the `isPlaying` flag.\r\n */export function getIsPlaying(){return isPlaying;}/**\r\n * Returns the value of the `isRotating` flag.\r\n * @returns {boolean} The value of the `isRotating` flag.\r\n */export function getIsRotating(){return isRotating;}","map":{"version":3,"names":["THREE","OrbitControls","Tween","Easing","update","isRotating","isPlaying","myModel","lastRenderTime","minDistance","controls","camera","scene","hemisphereLight","setupScene","canvas","document","getElementById","console","error","renderer","WebGLRenderer","setSize","clientWidth","clientHeight","body","appendChild","domElement","Scene","PerspectiveCamera","window","innerWidth","innerHeight","position","set","rotateSpeed","zoomSpeed","panSpeed","enablePan","enableDamping","enabled","HemisphereLight","add","animate","model","_animate","currentTime","delta","cameraPosition","Vector3","getWorldPosition","distanceToCenter","length","rotation","y","directionToCenter","clone","normalize","newCameraPosition","multiplyScalar","copy","render","requestAnimationFrame","updateControls","toggleIsPlaying","moveModelTo","toggleIsRotating","getIntersect","mouseX","mouseY","raycaster","Raycaster","mouseVector","Vector2","setFromCamera","intersectObjects","children","x","z","targetPosition","to","easing","Quadratic","Out","start","setCameraPosition","vector","Linear","In","onUpdate","lookAt","getIsPlaying","getIsRotating"],"sources":["C:/Users/esteb/Documents/GitHub/COTWQ-server/server/client/src/utils/scene.ts"],"sourcesContent":["// scene.ts\r\n\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\nimport { Tween, Easing, update } from '@tweenjs/tween.js';\r\n// Define variables\r\nlet isRotating: boolean = true;\r\nlet isPlaying: boolean = false;\r\nlet myModel: THREE.Object3D;\r\nlet lastRenderTime: number = 0;\r\nconst minDistance: number = 70;\r\nlet controls: OrbitControls;\r\nlet camera: THREE.PerspectiveCamera;\r\nlet scene: THREE.Scene;\r\nlet hemisphereLight: THREE.HemisphereLight;\r\n\r\n/**\r\n * Sets up the scene by creating a renderer, scene, camera, controls, and\r\n * directional light.\r\n * @returns An array containing the renderer and scene.\r\n */\r\nexport function setupScene(): [THREE.WebGLRenderer, THREE.Scene] {\r\n\t// Get a reference to the canvas element\r\n\tconst canvas: HTMLCanvasElement = document.getElementById(\"modelCanvas\") as HTMLCanvasElement;\r\n\r\n\t// Ensure the canvas element exists\r\n\tif (!canvas) {\r\n\t\tconsole.error(\"Canvas element 'modelCanvas' not found.\");\r\n\t\t// Handle the error or provide a fallback\r\n\t}\r\n\r\n\t// Create a WebGL renderer and set its size to match the canvas\r\n\tconst renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({ canvas });\r\n\trenderer.setSize(canvas.clientWidth, canvas.clientHeight);\r\n\tdocument.body.appendChild(renderer.domElement);\r\n\r\n\t// Create the scene\r\n\tscene = new THREE.Scene();\r\n\r\n\t// Create the camera\r\n\tcamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\r\n\tcamera.position.set(0, 0, 140);\r\n\r\n\t// Create the controls\r\n\tcontrols = new OrbitControls(camera, renderer.domElement);\r\n\tcontrols.rotateSpeed = 0.5;\r\n\tcontrols.zoomSpeed = 0.5;\r\n\tcontrols.panSpeed = 0.5;\r\n\tcontrols.enablePan = false;\r\n\tcontrols.enableDamping = true;\r\n\tcontrols.enabled = isPlaying;\r\n\r\n\t// Add directional light\r\n\themisphereLight = new THREE.HemisphereLight(0xffffff, 0.7);\r\n\tscene.add(hemisphereLight);\r\n\r\n\treturn [renderer, scene];\r\n}\r\n\r\n/**\r\n * Animates the scene.\r\n * @param {THREE.WebGLRenderer} renderer - The WebGL renderer.\r\n * @param {THREE.Object3D} model - The 3D object representing the model.\r\n */\r\nexport function animate(renderer: THREE.WebGLRenderer, model: THREE.Object3D): void {\r\n\tmyModel = model;\r\n\r\n\tfunction _animate(currentTime: number): void {\r\n\t\tconst delta: number = currentTime - lastRenderTime;\r\n\t\tconst cameraPosition: THREE.Vector3 = new THREE.Vector3();\r\n\t\tcamera.getWorldPosition(cameraPosition);\r\n\t\tconst distanceToCenter: number = cameraPosition.length();\r\n\r\n\t\t\r\n\t\tif (isRotating) {\r\n\t\t\tmyModel.rotation.y += 0.0005;\r\n\t\t}\r\n\r\n\t\tif (distanceToCenter < minDistance) {\r\n\t\t\tconst directionToCenter: THREE.Vector3 = cameraPosition.clone().normalize();\r\n\t\t\tconst newCameraPosition: THREE.Vector3 = directionToCenter.multiplyScalar(minDistance);\r\n\t\t\tcamera.position.copy(newCameraPosition);\r\n\t\t}\r\n\r\n\t\themisphereLight.position.copy(cameraPosition);\r\n\r\n\t\tif (delta >= 16) {\r\n\t\t\tcontrols.update();\r\n\t\t\trenderer.render(scene, camera);\r\n\t\t\tlastRenderTime = currentTime;\r\n\t\t}\r\n\r\n\t\trequestAnimationFrame(_animate);\r\n\t\tupdate();\r\n\t}\r\n\r\n\t_animate(0);\r\n}\r\n\r\n/**\r\n * Updates the state of controls based on the `isPlaying` flag.\r\n */\r\nfunction updateControls(): void {\r\n\tcontrols.enabled = isPlaying;\r\n}\r\n\r\n/**\r\n * Toggles the `isPlaying` flag.\r\n */\r\nexport function toggleIsPlaying(): void {\r\n\tisPlaying = !isPlaying;\r\n\tif (isPlaying) {\r\n\t\tmoveModelTo(myModel, 0, null, null);\r\n\t\tif (isRotating) toggleIsRotating();\r\n\t} else {\r\n\t\tmoveModelTo(myModel, 90, null, null);\r\n\t\tif (!isRotating) toggleIsRotating();\r\n\r\n\t}\r\n\r\n\tupdateControls(); // Call updateControls to ensure controls are updated\r\n}\r\n\r\n/**\r\n * Toggles the `isRotating` flag.\r\n */\r\nexport function toggleIsRotating(): void {\r\n\tisRotating = !isRotating;\r\n}\r\n\r\n/**\r\n * Gets intersections of a raycaster with objects in the scene based on mouse coordinates.\r\n * @param {number} mouseX - The X coordinate of the mouse.\r\n * @param {number} mouseY - The Y coordinate of the mouse.\r\n * @returns {THREE.Intersection[]} An array of intersections.\r\n */\r\nexport function getIntersect(mouseX: number, mouseY: number): THREE.Intersection[] {\r\n\t// Create a raycaster\r\n\tconst raycaster: THREE.Raycaster = new THREE.Raycaster();\r\n\r\n\t// Set raycaster origin as mouse position in NDC using Vector2\r\n\tconst mouseVector: THREE.Vector2 = new THREE.Vector2(mouseX, mouseY);\r\n\traycaster.setFromCamera(mouseVector, camera);\r\n\r\n\t// Perform raycasting\r\n\treturn raycaster.intersectObjects(scene.children, true);\r\n}\r\n\r\n/**\r\n * Moves the model to the specified position.\r\n * @param {THREE.Object3D} model - The 3D object representing the model.\r\n * @param {number | null} x - The X coordinate of the new position.\r\n * @param {number | null} y - The Y coordinate of the new position.\r\n * @param {number | null} z - The Z coordinate of the new position.\r\n */\r\nexport function moveModelTo(model: THREE.Object3D, x: number | null, y: number | null, z: number | null): void {\r\n\tconst targetPosition = {\r\n\t\tx: x !== null ? x : model.position.x,\r\n\t\ty: y !== null ? y : model.position.y,\r\n\t\tz: z !== null ? z : model.position.z,\r\n\t  };\r\n\t\r\n\tnew Tween(model.position)\r\n\t.to(targetPosition, 1500)\r\n\t.easing(Easing.Quadratic.Out)\r\n\t.start();\r\n}\r\n\r\n/**\r\n * Sets the camera position to the specified vector.\r\n * @param {THREE.Vector3} vector - The new camera position.\r\n */\r\nexport function setCameraPosition(vector: THREE.Vector3): void {\r\n\tconst cameraPosition: THREE.Vector3 = new THREE.Vector3();\r\n\tcamera.getWorldPosition(cameraPosition);\r\n\tconst directionToCenter: THREE.Vector3 = vector.clone().normalize();\r\n\tconst newCameraPosition: THREE.Vector3 = directionToCenter.multiplyScalar(cameraPosition.length());\r\n\t// camera.position.copy(newCameraPosition);\r\n\tnew Tween(cameraPosition)\r\n    .to(newCameraPosition, 1000)\r\n    .easing(Easing.Linear.In)\r\n    .onUpdate(() => {\r\n      camera.position.copy(cameraPosition);\r\n      camera.lookAt(directionToCenter);\r\n    })\r\n    .start();\r\n}\r\n\r\n/**\r\n * Returns the value of the `isPlaying` flag.\r\n * @returns {boolean} The value of the `isPlaying` flag.\r\n */\r\nexport function getIsPlaying(): boolean {\r\n\treturn isPlaying;\r\n}\r\n\r\n/**\r\n * Returns the value of the `isRotating` flag.\r\n * @returns {boolean} The value of the `isRotating` flag.\r\n */\r\nexport function getIsRotating(): boolean {\r\n\treturn isRotating;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}