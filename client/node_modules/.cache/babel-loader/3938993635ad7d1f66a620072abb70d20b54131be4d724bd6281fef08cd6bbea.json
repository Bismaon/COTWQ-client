{"ast":null,"code":"// ThreeScene.ts\nimport*as THREE from\"three\";import{Countries}from\"../models/Countries\";import{createTable,getIndexFromLocation}from\"../typescripts/countriesTable\";import{loadModel}from\"../utils/loader\";import{setupScene,animate,moveModelTo,getIsPlaying,getIsRotating,toggleIsRotating,setCameraPosition,getIntersect}from\"../utils/scene\";// Create variables\nlet allCountriesCaps;let allCountries;let modelParent;let globe;let isFollowing=false;const colorsArray=[];const colorDict={unknown:0,found:1,unavailable:2,error:3,selected:4};const countries=new Countries();let renderer;let scene;//!!!!!! CREATE A SETUP FUNCTION FOR EVERYTHING IN THIS FILE, SO CAN CALL FROM MODEL.TSX\n//!? Dunno if necessary anymore\nexport function setupModel(){[renderer,scene]=setupScene();// Destructure the result of setupScene()\n// Load and initialize the model\nloadAndInitializeModel().then(result=>{console.log(\"Loaded model successfully\");// Additional actions to execute after successful resolution\n}).catch(error=>{console.error(\"An error occurred:\",error);// This will execute if the Promise is rejected\nreturn;});createTable(countries.getCountriesArray());// Create table with countries\n}/**\r\n * Asynchronously loads and initializes the 3D model.\r\n */async function loadAndInitializeModel(){try{modelParent=await loadModel(scene,colorsArray);if(!modelParent){console.error(\"MODEL ERROR: Model is null or undefined.\");return;}animate(renderer,modelParent);// Start animation\nmoveModelTo(modelParent,90,null,null);// Move model to the right side of the screen\nglobe=modelParent.children[0];allCountriesCaps=globe.children[1];allCountries=globe.children[0];// Set countries to base color\nfor(let i=0;i<countries.getSize();i++){changeColorTo(countries.getCountriesArray()[i].getCountryLocation()[0],countries.getCountriesArray()[i].getCountryLocation()[1],\"unknown\");}}catch(error){console.error(\"An error occurred while loading the model:\",error);}}/**\r\n * Handles the mouse up event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */export function handleMouseUp(event){if(event.button===0&&!getIsPlaying()&&!getIsRotating()){toggleIsRotating();// Toggle rotation if not playing and not rotating\n}}/**\r\n * Handles the mouse down event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */export function handleMouseDown(event){if(event.button===0&&getIsPlaying()&&getIsRotating()){toggleIsRotating();// Toggle rotation if playing and rotating\n}}/**\r\n * Handles changes in the textbox input.\r\n */export function handleTextboxChange(_event,timer){const textBox=document.getElementById(\"answer-box-input\");const countryCounterDiv=document.getElementById(\"country-counter\");if(textBox&&timer){const countryName=processText(textBox.value);const indexCountry=countries.exists(countryName);if(indexCountry!==-1){const wantedCountry=countries.getCountriesArray()[indexCountry];if(foundSearch(wantedCountry,textBox)){timer.stop();}countryCounterDiv.textContent=String(countries.getFound());}}}/**\r\n * Checks if the wanted country is found, changes its status if not found,\r\n * updates its color on the globe, and handles related actions like clearing\r\n * the textbox and setting the camera position.\r\n * @param {Country} wantedCountry - The country to search for.\r\n * @param {HTMLInputElement} textBox - The textbox element associated with the search.\r\n */function foundSearch(wantedCountry,textBox){if(!wantedCountry.getFound()){const continentIndex=wantedCountry.getCountryLocation()[0];const countryIndex=wantedCountry.getCountryLocation()[1];setCountryIsFoundTo(wantedCountry,true);// Mark the country as found\nchangeColorTo(continentIndex,countryIndex,\"found\");// Change color of the found country\ntextBox.value=\"\";// Clear the textbox value\n// Get the 3D object representing the found country\nconst country=allCountries.children[continentIndex].children[countryIndex];const countryPosition=new THREE.Vector3();country.getWorldPosition(countryPosition);// Get the world position of the country\nif(isFollowing){setCameraPosition(countryPosition);// Set camera position to follow the country\n}}return countries.isAllFound();}/**\r\n * Sets the found status of the given country and increments the count of found countries.\r\n * Also sets the found status for all territories associated with the country.\r\n * @param {Country} wantedCountry - The country to mark as found.\r\n * @param {boolean} found - The new found status.\r\n */function setCountryIsFoundTo(wantedCountry,found){wantedCountry.setFound(found);// Set the found status of the main country\ncountries.incrementFound();// Increment the count of found countries\n// Set found status for all territories associated with the country\nwantedCountry.getTerritoriesLocation().forEach(location=>{if(location!==null){const country=countries.getCountriesArray()[getIndexFromLocation(location[0],location[1])];country.setFound(true);// Mark territory as found\n}});}/**\r\n * Processes text input to remove unnecessary characters and make it lowercase.\r\n * @param {string} name - The input text.\r\n * @returns {string} The processed text.\r\n */function processText(name){name=name.toLowerCase();const fullname=name.split(\" \");name=\"\";for(let i=0;i<fullname.length;i++){if(fullname[i][0]!==\"(\"){name+=fullname[i];}}return name;}/**\r\n * Handles the checkbox click event to enable/disable country following.\r\n */export function followCountry(event){const checkbox=event.target;isFollowing=checkbox.checked;}/**\r\n * Handles the mouse move event and intersection with the model.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */export function onMouseMove(event){const mouseX=event.clientX/window.innerWidth*2-1;const mouseY=-(event.clientY/window.innerHeight)*2+1;const intersects=getIntersect(mouseX,mouseY);if(intersects.length>0){const intersectedObject=intersects[0].object;if(isValidObject(intersectedObject)){updateCountryName(intersectedObject);}else{updateCountryName(null);}}else{updateCountryName(null);}}/**\r\n * Checks if the intersected object is valid (not water or continent boundaries).\r\n * @param {THREE.Object3D} intersectedObject - The intersected object.\r\n * @returns {boolean} True if the object is valid, false otherwise.\r\n */function isValidObject(intersectedObject){if(intersectedObject.name===\"water\")return false;const parentObj=intersectedObject.parent;if(!parentObj||parentObj.name===intersectedObject.name.slice(0,parentObj.name.length))return false;const continentIndex=getIndexFromObject3D(parentObj);const countryIndex=getIndexFromObject3D(intersectedObject);return countries.getCountriesArray()[getIndexFromLocation(continentIndex,countryIndex)].getFound()||!getIsPlaying();}/**\r\n * Updates the country name element if it exists.\r\n * @param {THREE.Object3D | null} intersectedObject - The intersected object.\r\n */function updateCountryName(intersectedObject){const countryNameElement=document.getElementById(\"country-name-container\");if(countryNameElement){if(intersectedObject==null||intersectedObject.parent==null){countryNameElement.textContent=\"\";}else{const continentIndex=getIndexFromObject3D(intersectedObject.parent);const countryIndex=getIndexFromObject3D(intersectedObject);const country=countries.getCountriesArray()[getIndexFromLocation(continentIndex,countryIndex)];countryNameElement.textContent=country.getCountryName();// Display country name\n}}}/**\r\n * Changes the color of the selected country on the globe.\r\n * @param {number} continent - The continent index.\r\n * @param {number} index - The index of the country.\r\n * @param {string} colorIndex - The index of the color in the colors array.\r\n */function changeColorTo(continent,index,colorIndex){const materialCloned=colorsArray[colorDict[colorIndex]].clone();const connectedLocations=[];const indexLoca=getIndexFromLocation(continent,index);const country=countries.getCountriesArray()[indexLoca];if(!country){console.error(\"ERROR: country is null\");return;}const ownerLocation=country.getOwnerLocation();if(ownerLocation){const owner=countries.getCountriesArray()[getIndexFromLocation(ownerLocation[0],ownerLocation[1])];connectedLocations.push(owner.getCountryLocation(),...owner.getTerritoriesLocation());}else{connectedLocations.push(country.getCountryLocation(),...country.getTerritoriesLocation());}for(let i=0;i<connectedLocations.length;i++){const tempContinentIndex=connectedLocations[i][0];const tempCountryIndex=connectedLocations[i][1];const cap=allCountriesCaps.children[tempContinentIndex].children[tempCountryIndex];const body=allCountries.children[tempContinentIndex].children[tempCountryIndex];if(cap instanceof THREE.Mesh)cap.material=materialCloned;if(body instanceof THREE.Mesh)body.material=materialCloned;}materialCloned.needsUpdate=true;}/**\r\n * Gets the index of the child object within its parent.\r\n * @param {THREE.Object3D} object - The child object.\r\n * @returns {number} The index of the child object within its parent.\r\n */function getIndexFromObject3D(object){const parentObj=object.parent;if(!parentObj)return-1;return parentObj.children.findIndex(obj=>obj===object);}","map":{"version":3,"names":["THREE","Countries","createTable","getIndexFromLocation","loadModel","setupScene","animate","moveModelTo","getIsPlaying","getIsRotating","toggleIsRotating","setCameraPosition","getIntersect","allCountriesCaps","allCountries","modelParent","globe","isFollowing","colorsArray","colorDict","unknown","found","unavailable","error","selected","countries","renderer","scene","setupModel","loadAndInitializeModel","then","result","console","log","catch","getCountriesArray","children","i","getSize","changeColorTo","getCountryLocation","handleMouseUp","event","button","handleMouseDown","handleTextboxChange","_event","timer","textBox","document","getElementById","countryCounterDiv","countryName","processText","value","indexCountry","exists","wantedCountry","foundSearch","stop","textContent","String","getFound","continentIndex","countryIndex","setCountryIsFoundTo","country","countryPosition","Vector3","getWorldPosition","isAllFound","setFound","incrementFound","getTerritoriesLocation","forEach","location","name","toLowerCase","fullname","split","length","followCountry","checkbox","target","checked","onMouseMove","mouseX","clientX","window","innerWidth","mouseY","clientY","innerHeight","intersects","intersectedObject","object","isValidObject","updateCountryName","parentObj","parent","slice","getIndexFromObject3D","countryNameElement","getCountryName","continent","index","colorIndex","materialCloned","clone","connectedLocations","indexLoca","ownerLocation","getOwnerLocation","owner","push","tempContinentIndex","tempCountryIndex","cap","body","Mesh","material","needsUpdate","findIndex","obj"],"sources":["C:/Users/esteb/Documents/GitHub/COTWQ-client/client/src/components/ThreeScene.ts"],"sourcesContent":["// ThreeScene.ts\r\n\r\nimport * as THREE from \"three\";\r\nimport { Countries } from \"../models/Countries\";\r\nimport { Country } from \"../models/Country\";\r\nimport { createTable, getIndexFromLocation } from \"../typescripts/countriesTable\";\r\nimport { loadModel } from \"../utils/loader\";\r\nimport { setupScene, animate, moveModelTo, getIsPlaying, getIsRotating, toggleIsRotating, setCameraPosition, getIntersect } from \"../utils/scene\";\r\nimport { Timer } from \"../utils/Timer\";\r\n\r\n// Create variables\r\nlet allCountriesCaps: THREE.Object3D;\r\nlet allCountries: THREE.Object3D;\r\nlet modelParent: THREE.Object3D;\r\nlet globe: THREE.Object3D;\r\nlet isFollowing: boolean = false;\r\nconst colorsArray: THREE.Material[] = [];\r\nconst colorDict: { [key: string]: number } = {\r\n\tunknown: 0,\r\n\tfound: 1,\r\n\tunavailable: 2,\r\n\terror: 3,\r\n\tselected: 4\r\n};\r\nconst countries: Countries = new Countries();\r\nlet renderer:THREE.WebGLRenderer;\r\nlet scene:THREE.Scene;\r\n//!!!!!! CREATE A SETUP FUNCTION FOR EVERYTHING IN THIS FILE, SO CAN CALL FROM MODEL.TSX\r\n//!? Dunno if necessary anymore\r\nexport function setupModel():void{\r\n\t[renderer, scene] = setupScene(); // Destructure the result of setupScene()\r\n\t\r\n\t// Load and initialize the model\r\n\tloadAndInitializeModel().then((result) => {\r\n\t\tconsole.log(\"Loaded model successfully\");\r\n\t\t// Additional actions to execute after successful resolution\r\n\t}).catch((error) => {\r\n\t\tconsole.error(\"An error occurred:\", error); // This will execute if the Promise is rejected\r\n\t\treturn;\r\n\t});\r\n\t\r\n\r\n\tcreateTable(countries.getCountriesArray()); // Create table with countries\r\n}\r\n\r\n/**\r\n * Asynchronously loads and initializes the 3D model.\r\n */\r\nasync function loadAndInitializeModel(): Promise<void> {\r\n\ttry {\r\n\t\tmodelParent = await loadModel(scene, colorsArray);\r\n\t\tif (!modelParent) {\r\n\t\t\tconsole.error(\"MODEL ERROR: Model is null or undefined.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tanimate(renderer, modelParent); // Start animation\r\n\t\tmoveModelTo(modelParent, 90, null, null); // Move model to the right side of the screen\r\n\t\tglobe = modelParent.children[0];\r\n\t\t\r\n\t\tallCountriesCaps = globe.children[1];\r\n\t\tallCountries = globe.children[0];\r\n\r\n\t\t// Set countries to base color\r\n\t\tfor (let i = 0; i < countries.getSize(); i++) {\r\n\t\t\tchangeColorTo(countries.getCountriesArray()[i].getCountryLocation()[0], countries.getCountriesArray()[i].getCountryLocation()[1], \"unknown\");\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.error(\"An error occurred while loading the model:\", error);\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles the mouse up event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function handleMouseUp(event: MouseEvent): void {\r\n\tif (event.button === 0 && !getIsPlaying() && !getIsRotating()) {\r\n\t\ttoggleIsRotating(); // Toggle rotation if not playing and not rotating\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles the mouse down event.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function handleMouseDown(event: MouseEvent): void {\r\n\tif (event.button === 0 && getIsPlaying() && getIsRotating()) {\r\n\t\ttoggleIsRotating(); // Toggle rotation if playing and rotating\r\n\t}\r\n}\r\n\r\n/**\r\n * Handles changes in the textbox input.\r\n */\r\nexport function handleTextboxChange(_event:React.FormEvent<HTMLInputElement>, timer:Timer|null): void {\r\n\tconst textBox: HTMLInputElement | null = document.getElementById(\"answer-box-input\") as HTMLInputElement;\r\n\tconst countryCounterDiv:HTMLDivElement|null = document.getElementById(\"country-counter\") as HTMLDivElement;\r\n\r\n\tif (textBox && timer) {\r\n\t\tconst countryName: string = processText(textBox.value);\r\n\t\tconst indexCountry: number = countries.exists(countryName);\r\n\r\n\t\tif (indexCountry !== -1) {\r\n\t\t\tconst wantedCountry: Country = countries.getCountriesArray()[indexCountry];\r\n\t\t\tif (foundSearch(wantedCountry, textBox)){\r\n\t\t\t\ttimer.stop();\r\n\t\t\t}\r\n\t\t\tcountryCounterDiv.textContent= String(countries.getFound());\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the wanted country is found, changes its status if not found,\r\n * updates its color on the globe, and handles related actions like clearing\r\n * the textbox and setting the camera position.\r\n * @param {Country} wantedCountry - The country to search for.\r\n * @param {HTMLInputElement} textBox - The textbox element associated with the search.\r\n */\r\nfunction foundSearch(wantedCountry: Country, textBox: HTMLInputElement): boolean {\r\n\tif (!wantedCountry.getFound()) {\r\n\t\tconst continentIndex: number = wantedCountry.getCountryLocation()[0];\r\n\t\tconst countryIndex: number = wantedCountry.getCountryLocation()[1];\r\n\r\n\t\tsetCountryIsFoundTo(wantedCountry, true); // Mark the country as found\r\n\t\tchangeColorTo(continentIndex, countryIndex, \"found\"); // Change color of the found country\r\n\t\ttextBox.value = \"\"; // Clear the textbox value\r\n\r\n\t\t// Get the 3D object representing the found country\r\n\t\tconst country: THREE.Object3D = allCountries.children[continentIndex].children[countryIndex];\r\n\r\n\t\tconst countryPosition: THREE.Vector3 = new THREE.Vector3();\r\n\t\tcountry.getWorldPosition(countryPosition); // Get the world position of the country\r\n\r\n\t\tif (isFollowing) {\r\n\t\t\tsetCameraPosition(countryPosition); // Set camera position to follow the country\r\n\t\t}\t\r\n\t}\r\n\r\n\treturn countries.isAllFound();\r\n}\r\n\r\n\r\n/**\r\n * Sets the found status of the given country and increments the count of found countries.\r\n * Also sets the found status for all territories associated with the country.\r\n * @param {Country} wantedCountry - The country to mark as found.\r\n * @param {boolean} found - The new found status.\r\n */\r\nfunction setCountryIsFoundTo(wantedCountry: Country, found: boolean): void {\r\n\twantedCountry.setFound(found); // Set the found status of the main country\r\n\tcountries.incrementFound(); // Increment the count of found countries\r\n\r\n\t// Set found status for all territories associated with the country\r\n\twantedCountry.getTerritoriesLocation().forEach((location: number[]) => {\r\n\t\tif (location !== null) {\r\n\t\t\tconst country: Country = countries.getCountriesArray()[getIndexFromLocation(location[0], location[1])];\r\n\t\t\tcountry.setFound(true); // Mark territory as found\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Processes text input to remove unnecessary characters and make it lowercase.\r\n * @param {string} name - The input text.\r\n * @returns {string} The processed text.\r\n */\r\nfunction processText(name: string): string {\r\n\tname = name.toLowerCase();\r\n\tconst fullname: string[] = name.split(\" \");\r\n\tname = \"\";\r\n\r\n\tfor (let i = 0; i < fullname.length; i++) {\r\n\t\tif (fullname[i][0] !== \"(\") {\r\n\t\t\tname += fullname[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn name;\r\n}\r\n\r\n/**\r\n * Handles the checkbox click event to enable/disable country following.\r\n */\r\nexport function followCountry(event: React.ChangeEvent<HTMLInputElement>): void{\r\n\tconst checkbox: HTMLInputElement = event.target;\r\n\tisFollowing = checkbox.checked;\r\n  }\r\n\r\n/**\r\n * Handles the mouse move event and intersection with the model.\r\n * @param {MouseEvent} event - The MouseEvent object.\r\n */\r\nexport function onMouseMove(event: MouseEvent): void {\r\n\tconst mouseX: number = (event.clientX / window.innerWidth) * 2 - 1;\r\n\tconst mouseY: number = -(event.clientY / window.innerHeight) * 2 + 1;\r\n\tconst intersects: THREE.Intersection[] = getIntersect(mouseX, mouseY);\r\n\r\n\tif (intersects.length > 0) {\r\n\t\tconst intersectedObject: THREE.Object3D = intersects[0].object;\r\n\t\tif (isValidObject(intersectedObject)) {\r\n\t\t\tupdateCountryName(intersectedObject);\r\n\t\t} else{\r\n\t\t\tupdateCountryName(null);\r\n\t\t}\r\n\t} else {\r\n\t\tupdateCountryName(null);\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the intersected object is valid (not water or continent boundaries).\r\n * @param {THREE.Object3D} intersectedObject - The intersected object.\r\n * @returns {boolean} True if the object is valid, false otherwise.\r\n */\r\nfunction isValidObject(intersectedObject: THREE.Object3D): boolean {\r\n\tif (intersectedObject.name === \"water\") return false;\r\n\tconst parentObj: THREE.Object3D | null = intersectedObject.parent;\r\n\r\n\tif (!parentObj || parentObj.name === intersectedObject.name.slice(0, parentObj.name.length)) return false;\r\n\r\n\tconst continentIndex: number = getIndexFromObject3D(parentObj);\r\n\tconst countryIndex: number = getIndexFromObject3D(intersectedObject);\r\n\treturn countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)].getFound() || !getIsPlaying();\r\n}\r\n\r\n/**\r\n * Updates the country name element if it exists.\r\n * @param {THREE.Object3D | null} intersectedObject - The intersected object.\r\n */\r\nfunction updateCountryName(intersectedObject: THREE.Object3D | null): void {\r\n\tconst countryNameElement: HTMLElement | null = document.getElementById(\"country-name-container\");\r\n\tif (countryNameElement) {\r\n\t\tif (intersectedObject == null || intersectedObject.parent == null) {\r\n\t\t\tcountryNameElement.textContent = \"\";\r\n\t\t} else {\r\n\t\t\tconst continentIndex: number = getIndexFromObject3D(intersectedObject.parent);\r\n\t\t\tconst countryIndex: number = getIndexFromObject3D(intersectedObject);\r\n\t\t\tconst country: Country = countries.getCountriesArray()[getIndexFromLocation(continentIndex, countryIndex)];\r\n\t\t\tcountryNameElement.textContent = country.getCountryName(); // Display country name\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Changes the color of the selected country on the globe.\r\n * @param {number} continent - The continent index.\r\n * @param {number} index - The index of the country.\r\n * @param {string} colorIndex - The index of the color in the colors array.\r\n */\r\nfunction changeColorTo(continent: number, index: number, colorIndex: string): void {\r\n\tconst materialCloned: THREE.Material = colorsArray[colorDict[colorIndex]].clone();\r\n\tconst connectedLocations: number[][] = [];\r\n\r\n\tconst indexLoca = getIndexFromLocation(continent, index);\r\n\tconst country: Country | null = countries.getCountriesArray()[indexLoca];\r\n\r\n\tif (!country) {\r\n\t\tconsole.error(\"ERROR: country is null\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst ownerLocation: number[] | null = country.getOwnerLocation();\r\n\tif (ownerLocation) {\r\n\t\tconst owner: Country = countries.getCountriesArray()[getIndexFromLocation(ownerLocation[0], ownerLocation[1])];\r\n\t\tconnectedLocations.push(owner.getCountryLocation(), ...owner.getTerritoriesLocation());\r\n\t} else {\r\n\t\tconnectedLocations.push(country.getCountryLocation(), ...country.getTerritoriesLocation());\r\n\t}\r\n\t\r\n\r\n\tfor (let i = 0; i < connectedLocations.length; i++) {\r\n\t\tconst tempContinentIndex: number = connectedLocations[i][0];\r\n\t\tconst tempCountryIndex: number = connectedLocations[i][1];\r\n\r\n\t\tconst cap: THREE.Object3D = allCountriesCaps.children[tempContinentIndex].children[tempCountryIndex];\r\n\t\tconst body: THREE.Object3D = allCountries.children[tempContinentIndex].children[tempCountryIndex];\r\n\r\n\t\tif (cap instanceof THREE.Mesh) cap.material = materialCloned;\r\n\t\tif (body instanceof THREE.Mesh) body.material = materialCloned;\r\n\t}\r\n\r\n\tmaterialCloned.needsUpdate = true;\r\n}\r\n\r\n/**\r\n * Gets the index of the child object within its parent.\r\n * @param {THREE.Object3D} object - The child object.\r\n * @returns {number} The index of the child object within its parent.\r\n */\r\nfunction getIndexFromObject3D(object: THREE.Object3D): number {\r\n\tconst parentObj: THREE.Object3D | null = object.parent;\r\n\tif (!parentObj) return -1;\r\n\treturn parentObj.children.findIndex(obj => obj === object);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}